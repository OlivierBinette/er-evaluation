
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>er_evaluation.error_analysis &#8212; ER-Evaluation  documentation</title>
  <script>
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1e1de1a1873e13ef5536" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1e1de1a1873e13ef5536" rel="stylesheet">

  
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx_lesson.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1e1de1a1873e13ef5536">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/minipres.js"></script>
    <script src="../../_static/tabs.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/er_evaluation/error_analysis';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">

  
  <input type="checkbox" class="sidebar-toggle" name="__primary" id="__primary">
  <label class="overlay overlay-primary" for="__primary"></label>

  
  <input type="checkbox" class="sidebar-toggle" name="__secondary" id="__secondary">
  <label class="overlay overlay-secondary" for="__secondary"></label>

  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
      
<form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
    </div>
  </div>

  
  <nav class="bd-header navbar navbar-expand-lg bd-navbar" id="navbar-main"><div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
      <span class="fa-solid fa-bars"></span>
  </label>
  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../index.html">

  
  
  
  
  
  
  

  
  
    <p class="title logo__title">ER-Evaluation  documentation</p>
  
</a>
    
  </div>

  
  <div class="col-lg-9 navbar-header-items">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                <li class="nav-item">
                    <a class="nav-link" href="../../readme.html">
                        README
                    </a>
                </li>
                

                <li class="nav-item">
                    <a class="nav-link" href="../../er_evaluation.html">
                        API Doc
                    </a>
                </li>
                
    </ul>
</nav>
      </div>
      
    </div>

    <div id="navbar-end">
      <div class="navbar-end-item navbar-end__search-button-container">
        
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          <a href="https://github.com/OlivierBinette/er-evaluation" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-toggle="tooltip"><span><i class="fa-brands fa-square-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>


  
  <div class="search-button-container--mobile">
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
  </div>

  
  <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
  </label>
  

</div>
  </nav>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        
  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                <li class="nav-item">
                    <a class="nav-link" href="../../readme.html">
                        README
                    </a>
                </li>
                

                <li class="nav-item">
                    <a class="nav-link" href="../../er_evaluation.html">
                        API Doc
                    </a>
                </li>
                
    </ul>
</nav>
      </div>
      
      </div>
    

    
    
    <div class="sidebar-header-items__end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          <a href="https://github.com/OlivierBinette/er-evaluation" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-toggle="tooltip"><span><i class="fa-brands fa-square-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
      </ul>
      </div>
      
    </div>
    
  </div>

  

  
  <div class="sidebar-end-items sidebar-primary__section">
    <div class="sidebar-end-items__item">
    </div>
  </div>

      </div>
      <main class="bd-main">
        
        
        <div class="bd-content">
          <div class="bd-article-container">
            
            <div class="bd-header-article">
                
            </div>
            
            
            <article class="bd-article" role="main">
              
  <h1>Source code for er_evaluation.error_analysis</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">=============================================================</span>
<span class="sd">Error Analysis: Analyze Errors Based on Ground Truth Clusters</span>
<span class="sd">=============================================================</span>

<span class="sd">The **error_analysis** submodule provides a set of tools to analyze errors, given a set of ground truth clusters. These ground truth clusters may correspond to a benchmark dataset which is *complete* (all of the entities within it are fully resolved and have no missing links), or to a probability sample of ground truth clusters. For more information on the underlying methodology, please refer to [XX].</span>

<span class="sd">The key assumptions used for this module are:</span>
<span class="sd">1. A *predicted* clustering is available as a membership vector (named  `prediction` throughout).</span>
<span class="sd">2. A set of ground truth clusters is available as a membership vector (named `sample` throughout).</span>

<span class="sd">Given these two elements, error metrics are associated to each true entity (corresponding to a cluster in `sample`). The corresponding error space can then be analyzed to identify systematic errors, identify performance disparities, and investigate root causes. </span>

<span class="sd">**Toy Example**</span>

<span class="sd">For example, consider the following set of ground truth clusters and predicted clusters of records :math:`1,2,\dots, 8`::</span>

<span class="sd">                             ┌───────┐  ┌─────┐  ┌───┐</span>
<span class="sd">                             │ 1   2 │  │  4  │  │ 6 │  ┌───┐</span>
<span class="sd">              True clusters: │       │  │     │  │   │  │ 8 │</span>
<span class="sd">                             │   3   │  │  5  │  │ 7 │  └───┘</span>
<span class="sd">                             └───────┘  └─────┘  └───┘   c4</span>
<span class="sd">                                 c1        c2      c3</span>
<span class="sd">    </span>
<span class="sd">                             ┌───────┐  ┌─────┐  ┌──────────┐</span>
<span class="sd">                             │ 1   2 │  │  4  │  │ 6        │</span>
<span class="sd">         Predicted clusters: ├───────┴──┴─────┤  │        8 │</span>
<span class="sd">                             │   3         5  │  │ 7        │</span>
<span class="sd">                             └────────────────┘  └──────────┘</span>
<span class="sd">    </span>

<span class="sd">Assume that the ground truth clusters `c1`, `c2`, and `c4` are available in a benchmark dataset `sample`. Then, we have::</span>

<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; prediction = pd.Series(index=[1,2,3,4,5,6,7,8], data=[1,1,2,3,2,4,4,4])</span>
<span class="sd">    &gt;&gt;&gt; sample = pd.Series(index=[1,2,3,4,5,8], data=[&quot;c1&quot;, &quot;c1&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c2&quot;, &quot;c4&quot;])</span>

<span class="sd">The following error metrics, namely the splitting entropy, expected number of extraneous links, and expected number of missing links, are used to quantify errors associated with each ground truth cluster. Refer to the API documentation for full definitions::</span>

<span class="sd">    &gt;&gt;&gt; from er_evaluation.error_analysis import (splitting_entropy, expected_extra_links, expected_missing_links)</span>

<span class="sd">    &gt;&gt;&gt; expected_extra_links(prediction, sample)</span>
<span class="sd">    sample</span>
<span class="sd">    c1    0.333333</span>
<span class="sd">    c2    0.500000</span>
<span class="sd">    c4    2.000000</span>
<span class="sd">    Name: expected_extra_links, dtype: float64</span>

<span class="sd">    &gt;&gt;&gt; expected_missing_links(prediction, sample)</span>
<span class="sd">    sample</span>
<span class="sd">    c1    1.333333</span>
<span class="sd">    c2    1.000000</span>
<span class="sd">    c4    0.000000</span>
<span class="sd">    Name: expected_missing_links, dtype: float64</span>

<span class="sd">    &gt;&gt;&gt; splitting_entropy(prediction, sample)</span>
<span class="sd">    sample</span>
<span class="sd">    c1    1.889882</span>
<span class="sd">    c2    2.000000</span>
<span class="sd">    c4    1.000000</span>
<span class="sd">    Name: splitting_entropy_1, dtype: float64</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">comb</span>


<div class="viewcode-block" id="count_extra_links"><a class="viewcode-back" href="../../er_evaluation.error_analysis.html#er_evaluation.error_analysis.count_extra_links">[docs]</a><span class="k">def</span> <span class="nf">count_extra_links</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span> <span class="n">sample</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Count number of extraneous links to sampled clusters.</span>

<span class="sd">    Given a predicted disambiguation `prediction` and a sample of true clusters `sample`, both represented as membership vectors, this functions returns the count of extraneous links for each true cluster. This is a pandas Series indexed by true cluster identifier and with values corresponding to the counts of extraneous links.</span>

<span class="sd">    Count of Extraneous Links</span>
<span class="sd">        For a given sampled cluster :math:`c` with records :math:`r \in c`, let :math:`A_r` be the set of records which are erroneously linked to :math:`r` in the predicted clustering. That is, if :math:`\hat c(r)` is the predicted cluster containing :math:`r`, then :math:`A_r = \hat c(r) \backslash c` Then the count of extraneous links for :math:`c` is :math:`\sum_{r\in c} \lvert A_r \rvert`.</span>

<span class="sd">    Args:</span>
<span class="sd">        prediction (Series): Membership vector representing a predicted disambiguation.</span>
<span class="sd">        sample (Series): Membership vector representing a set of true clusters.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Series: Pandas Series indexed by true cluster identifiers (unique values in `sample`) and with values corresponding to the count of extraneous links.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; prediction = pd.Series(index=[1,2,3,4,5,6,7,8], data=[1,1,2,3,2,4,4,4])</span>
<span class="sd">        &gt;&gt;&gt; sample = pd.Series(index=[1,2,3,4,5,8], data=[&quot;c1&quot;, &quot;c1&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c2&quot;, &quot;c4&quot;])</span>
<span class="sd">        &gt;&gt;&gt; count_extra_links(prediction, sample)</span>
<span class="sd">        sample</span>
<span class="sd">        c1    1</span>
<span class="sd">        c2    1</span>
<span class="sd">        c4    2</span>
<span class="sd">        Name: count_extra_links, dtype: int64</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Index of elements with a predicted cluster intersecting sampled clusters:</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">prediction</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">prediction</span><span class="p">[</span><span class="n">prediction</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">index</span><span class="p">)])</span>
    <span class="n">relevant_predictions</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="n">I</span><span class="p">]</span>

    <span class="n">outer</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;prediction&quot;</span><span class="p">:</span> <span class="n">relevant_predictions</span><span class="p">,</span> <span class="s2">&quot;sample&quot;</span><span class="p">:</span> <span class="n">sample</span><span class="p">},</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">lambd</span><span class="p">(</span><span class="n">sample_cluster</span><span class="p">):</span>
        <span class="c1"># Number of elements within sampled cluster split across predicted clusters:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">sample_cluster</span><span class="p">)</span>
        <span class="c1"># Number of elements within predicted clusters (restricted to current sampled cluster):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">outer</span><span class="o">.</span><span class="n">prediction</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()[</span><span class="n">p</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">n_links</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">comb</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">n_links</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">outer</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;sample&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">lambd</span><span class="p">)</span><span class="o">.</span><span class="n">prediction</span>
    <span class="n">result</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;count_extra_links&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="expected_extra_links"><a class="viewcode-back" href="../../er_evaluation.error_analysis.html#er_evaluation.error_analysis.expected_extra_links">[docs]</a><span class="k">def</span> <span class="nf">expected_extra_links</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span> <span class="n">sample</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expected number of extraneous links to records in sampled clusters.</span>

<span class="sd">    Given a predicted disambiguation `prediction` and a sample of true clusters `sample`, both represented as membership vectors, this functions returns the expected number of extraneous links for each true cluster. This is a pandas Series indexed by true cluster identifier and with values corresponding to the expected number of extraneous links.</span>

<span class="sd">    Expected Number of Extraneous Links</span>
<span class="sd">        For a given sampled cluster :math:`c` with records :math:`r \in c`, let :math:`A_r` be the set of records which are erroneously linked to :math:`r` in the predicted clustering. That is, if :math:`\hat c(r)` is the predicted cluster containing :math:`r`, then :math:`A_r = \hat c(r) \backslash c` Then the expected number of extraneous links for :math:`c` is :math:` \frac{1}{\lvert c \rvert}\sum_{r\in c} \lvert A_r \rvert :math:`. This is the expected number of erroneous links to a random record :math:`r \in c`.</span>

<span class="sd">    Args:</span>
<span class="sd">        prediction (Series): Membership vector representing a predicted disambiguation.</span>
<span class="sd">        sample (Series): Membership vector representing a set of true clusters.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Series: Pandas Series indexed by true cluster identifiers (unique values in `sample`) and with values corresponding to the expected number of extraneous links.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; prediction = pd.Series(index=[1,2,3,4,5,6,7,8], data=[1,1,2,3,2,4,4,4])</span>
<span class="sd">        &gt;&gt;&gt; sample = pd.Series(index=[1,2,3,4,5,8], data=[&quot;c1&quot;, &quot;c1&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c2&quot;, &quot;c4&quot;])</span>
<span class="sd">        &gt;&gt;&gt; expected_extra_links(prediction, sample)</span>
<span class="sd">        sample</span>
<span class="sd">        c1    0.333333</span>
<span class="sd">        c2    0.500000</span>
<span class="sd">        c4    2.000000</span>
<span class="sd">        Name: expected_extra_links, dtype: float64</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">count_extra_links</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span> <span class="n">sample</span><span class="p">)</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">/</span> <span class="n">sizes</span>
    <span class="n">result</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;expected_extra_links&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="count_missing_links"><a class="viewcode-back" href="../../er_evaluation.error_analysis.html#er_evaluation.error_analysis.count_missing_links">[docs]</a><span class="k">def</span> <span class="nf">count_missing_links</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span> <span class="n">sample</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Count number of missing links to sampled clusters.</span>

<span class="sd">    Given a predicted disambiguation `prediction` and a sample of true clusters `sample`, both represented as membership vectors, this functions returns the count of missing links for each true cluster. This is a pandas Series indexed by true cluster identifier and with values corresponding to the counts of missing links.</span>

<span class="sd">    Count of Missing Links</span>
<span class="sd">        For a given sampled cluster :math:`c` with records :math:`r \in c`, let :math:`B_r` be the set of records which are missing from the predicted cluster containing :math:`r`. That is, if :math:`\hat c(r)` is the predicted cluster containing :math:`r`, then :math:`B_r = c \backslash \hat c(r)`. Then the count of missing links for :math:`c` is :math:`\sum_{r\in c} \lvert B_r \rvert :math:`.</span>

<span class="sd">    Args:</span>
<span class="sd">        prediction (Series): Membership vector representing a predicted disambiguation.</span>
<span class="sd">        sample (Series): Membership vector representing a set of true clusters.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Series: Pandas Series indexed by true cluster identifiers (unique values in `sample`) and with values corresponding to the count of extraneous links.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; prediction = pd.Series(index=[1,2,3,4,5,6,7,8], data=[1,1,2,3,2,4,4,4])</span>
<span class="sd">        &gt;&gt;&gt; sample = pd.Series(index=[1,2,3,4,5,8], data=[&quot;c1&quot;, &quot;c1&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c2&quot;, &quot;c4&quot;])</span>
<span class="sd">        &gt;&gt;&gt; count_missing_links(prediction, sample)</span>
<span class="sd">        sample</span>
<span class="sd">        c1    4</span>
<span class="sd">        c2    2</span>
<span class="sd">        c4    0</span>
<span class="sd">        Name: count_missing_links, dtype: int64</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Index of elements with a predicted cluster intersecting sampled clusters:</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">prediction</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">prediction</span><span class="p">[</span><span class="n">prediction</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">index</span><span class="p">)])</span>
    <span class="n">relevant_predictions</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="n">I</span><span class="p">]</span>

    <span class="n">outer</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;prediction&quot;</span><span class="p">:</span> <span class="n">relevant_predictions</span><span class="p">,</span> <span class="s2">&quot;sample&quot;</span><span class="p">:</span> <span class="n">sample</span><span class="p">},</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">lambd</span><span class="p">(</span><span class="n">sample_cluster</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">sample_cluster</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">n_links</span> <span class="o">=</span> <span class="n">comb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_links</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">outer</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;sample&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">lambd</span><span class="p">)</span><span class="o">.</span><span class="n">prediction</span>
    <span class="n">result</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;count_missing_links&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="expected_missing_links"><a class="viewcode-back" href="../../er_evaluation.error_analysis.html#er_evaluation.error_analysis.expected_missing_links">[docs]</a><span class="k">def</span> <span class="nf">expected_missing_links</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span> <span class="n">sample</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expected number of missing links to records in sampled clusters.</span>

<span class="sd">    Given a predicted disambiguation `prediction` and a sample of true clusters `sample`, both represented as membership vectors, this functions returns the expected number of missing links for each true cluster. This is a pandas Series indexed by true cluster identifier and with values corresponding to the expected number of missing links.</span>

<span class="sd">    Expected Number of Missing Links</span>
<span class="sd">        For a given sampled cluster  :math:`c` with records  :math:`r \in c`, let :math:`B_r` be the set of records which are missing from the predicted cluster containing :math:`r`. That is, if :math:`\hat c(r)` is the predicted cluster containing :math:`r`, then :math:`B_r = c \backslash \hat c(r)`. Then the expected number of missing links for :math:`c` is :math:`\sum_{r\in c} \lvert B_r \rvert / \lvert c \rvert :math:`.</span>

<span class="sd">    Args:</span>
<span class="sd">        prediction (Series): Membership vector representing a predicted disambiguation.</span>
<span class="sd">        sample (Series): Membership vector representing a set of true clusters.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Series: Pandas Series indexed by true cluster identifiers (unique values in `sample`) and with values corresponding to the expected number of missing links.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; prediction = pd.Series(index=[1,2,3,4,5,6,7,8], data=[1,1,2,3,2,4,4,4])</span>
<span class="sd">        &gt;&gt;&gt; sample = pd.Series(index=[1,2,3,4,5,8], data=[&quot;c1&quot;, &quot;c1&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c2&quot;, &quot;c4&quot;])</span>
<span class="sd">        &gt;&gt;&gt; expected_missing_links(prediction, sample)</span>
<span class="sd">        sample</span>
<span class="sd">        c1    1.333333</span>
<span class="sd">        c2    1.000000</span>
<span class="sd">        c4    0.000000</span>
<span class="sd">        Name: expected_missing_links, dtype: float64</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">count_missing_links</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span> <span class="n">sample</span><span class="p">)</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">/</span> <span class="n">sizes</span>
    <span class="n">result</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;expected_missing_links&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="splitting_entropy"><a class="viewcode-back" href="../../er_evaluation.error_analysis.html#er_evaluation.error_analysis.splitting_entropy">[docs]</a><span class="k">def</span> <span class="nf">splitting_entropy</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splitting entropy of true clusters</span>

<span class="sd">    This function returns the splitting entropy, defined below, of each entity represented in the sampled clusters `sample`.</span>

<span class="sd">    Splitting Entropy:</span>
<span class="sd">        Let :math:`\hat{\mathcal{C}}` be a clustering of records :math:`\mathcal{R}` into **predicted** entities. For a given entity represented by a cluster :math:`c`, the splitting entropy is defined as the exponentiated Shannon entropy of the set of cluster sizes :math:`\{\lvert \hat c \cap c \rvert \mid \hat c \in \widehat{\mathcal{C}},\, \lvert \hat c \cap c \rvert &gt; 0 \}`. That is, with using the convention that :math:`0 \cdot \log (0) = 0`, we have</span>

<span class="sd">        .. math::</span>

<span class="sd">            E_{\text{split}}(c) = \exp\left \{-\sum_{\hat c \in \widehat{\mathcal{C}}} \frac{\lvert\hat c \cap c \rvert}{\sum_{\hat c&#39; \in \widehat{\mathcal{C}}} \lvert \hat c&#39; \cap c \rvert } \log \left(\frac{\lvert\hat c \cap c \rvert}{\sum_{\hat c&#39; \in \widehat{\mathcal{C}}} \lvert \hat c&#39; \cap c \rvert }\right) \right \}.</span>

<span class="sd">    Args:</span>
<span class="sd">        prediction (Series): Membership vector representing a predicted disambiguation.</span>
<span class="sd">        sample (Series): Membership vector representing a set of true clusters.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Series: Pandas Series indexed by true cluster identifiers (unique values in `sample`) and with values corresponding to the splitting entropy.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; prediction = pd.Series(index=[1,2,3,4,5,6,7,8], data=[1,1,2,3,2,4,4,4])</span>
<span class="sd">        &gt;&gt;&gt; sample = pd.Series(index=[1,2,3,4,5,8], data=[&quot;c1&quot;, &quot;c1&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c2&quot;, &quot;c4&quot;])</span>
<span class="sd">        &gt;&gt;&gt; splitting_entropy(prediction, sample)</span>
<span class="sd">        sample</span>
<span class="sd">        c1    1.889882</span>
<span class="sd">        c2    2.000000</span>
<span class="sd">        c4    1.000000</span>
<span class="sd">        Name: splitting_entropy_1, dtype: float64</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Index of elements with a predicted cluster intersecting sampled clusters:</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">prediction</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">prediction</span><span class="p">[</span><span class="n">prediction</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">index</span><span class="p">)])</span>
    <span class="n">relevant_predictions</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="n">I</span><span class="p">]</span>

    <span class="n">outer</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;prediction&quot;</span><span class="p">:</span> <span class="n">relevant_predictions</span><span class="p">,</span> <span class="s2">&quot;sample&quot;</span><span class="p">:</span> <span class="n">sample</span><span class="p">},</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">lambd</span><span class="p">(</span><span class="n">sample_cluster</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">sample_cluster</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">)))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="n">alpha</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">outer</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;sample&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">lambd</span><span class="p">)</span><span class="o">.</span><span class="n">prediction</span>
    <span class="n">result</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;splitting_entropy_</span><span class="si">{</span><span class="n">alpha</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>
</pre></div>

            </article>
            
            
            
            <footer class="bd-footer-article">
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
            
          </div>
          
          
          
            <div class="bd-sidebar-secondary bd-toc">
              
<div class="toc-item">
  
<div id="searchbox"></div>
</div>

<div class="toc-item">
  
</div>

<div class="toc-item">
  
</div>

            </div>
          
          
        </div>
        <footer class="bd-footer-content">
          <div class="bd-footer-content__inner">
            
          </div>
        </footer>
        
      </main>
    </div>
  </div>

  
    
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1e1de1a1873e13ef5536"></script>

  <footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    
<p class="copyright">

    &copy; Copyright 2022, Olivier Binette.<br>

</p>

  </div>
  
  <div class="footer-item">
    
<p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br>
</p>

  </div>
  
</div>
  </footer>
  </body>
</html>